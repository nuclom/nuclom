---
title: "Testing Guide"
description: "Testing strategies, patterns, and best practices for the Nuclom video collaboration platform"
icon: "flask"
---

## Testing Strategy

### Testing Pyramid

```
    /\
   /  \     E2E Tests (Few, High-level)
  /____\    Integration Tests (Some, API & Components)
 /______\   Unit Tests (Many, Functions & Hooks)
```

### Current Status

- **E2E Tests**: Configured with Playwright. Tests are located in `tests/e2e/` and run via GitHub Actions when Vercel deployments complete.
- **Unit/Integration Tests**: Configured with Vitest. Tests are located in `__tests__` directories or files with `.test.ts` suffix.

### E2E Test Architecture

The E2E test pipeline uses a two-workflow system optimized for Vercel's monorepo deployments:

1. **`e2e-trigger.yml`**: Listens for Vercel deployment events via `repository_dispatch`:
   - `vercel.deployment.success` - Deployment promoted to production
   - `vercel.deployment.ready` - Preview deployment ready
   - `vercel.deployment.skipped` - Deployment skipped (no changes affected project)

2. **`e2e.yml`**: Runs the actual Playwright tests with sharding for parallel execution

This architecture handles Vercel's "Skip Unaffected Projects" feature, which only deploys apps that have changes. The trigger workflow uses Turborepo's `--dry-run` to detect which apps are affected and only waits for those deployments.

## Running E2E Tests

```bash
# Run all E2E tests
pnpm test:e2e

# Run tests with UI mode (interactive)
pnpm test:e2e:ui

# Run tests in headed mode (see browser)
pnpm test:e2e:headed

# View test report
pnpm test:e2e:report
```

### E2E Test Coverage

The E2E test suite covers:

| Area | Coverage |
|------|----------|
| Landing Page | Hero section, features, pricing, about, footer, navigation |
| Authentication | Login form, registration form, OAuth buttons, validation, redirects |
| Organization Dashboard | Video sections, empty states, navigation |
| Video Upload | Upload page layout, drag-and-drop area, back navigation |
| Video Management | Video list, detail pages, search, my-videos, shared, channels, series |
| Settings | Profile, organization, members settings pages |
| Public Pages | Privacy policy, terms of service, support, contact, 404 handling |
| Performance | Page load times |

## Running Unit Tests

```bash
# Run all unit tests
pnpm test

# Run tests in watch mode
pnpm test -- --watch

# Run tests with coverage
pnpm test:coverage

# Run tests with UI mode
pnpm test:ui
```

## Test Configuration

### Vitest Configuration

```typescript
// vitest.config.ts
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";
import { resolve } from "path";

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom",
    setupFiles: ["./src/test/setup.ts"],
    include: ["**/__tests__/**/*.test.{ts,tsx}", "**/*.test.{ts,tsx}"],
    exclude: ["node_modules", ".next", "e2e"],
    globals: true,
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: ["node_modules", ".next", "e2e"],
    },
  },
  resolve: {
    alias: {
      "@": resolve(__dirname, "./src"),
    },
  },
});
```

### Test Setup File

```typescript
// src/test/setup.ts
import "@testing-library/jest-dom/vitest";
import { vi } from "vitest";

// Mock next/navigation
vi.mock("next/navigation", () => ({
  useRouter: () => ({
    push: vi.fn(),
    replace: vi.fn(),
    back: vi.fn(),
  }),
  useSearchParams: () => ({
    get: vi.fn(),
  }),
  usePathname: () => "/",
}));

// Mock next-themes
vi.mock("next-themes", () => ({
  useTheme: () => ({
    theme: "light",
    setTheme: vi.fn(),
  }),
}));
```

## Unit Testing

### Testing Utilities

```typescript
// src/lib/test-utils.tsx
import { render, RenderOptions } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ThemeProvider } from "@/components/theme-provider";
import { ReactElement } from "react";

const createTestQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });

const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  const queryClient = createTestQueryClient();

  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider attribute="class" defaultTheme="light">
        {children}
      </ThemeProvider>
    </QueryClientProvider>
  );
};

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, "wrapper">
) => render(ui, { wrapper: AllTheProviders, ...options });

export * from "@testing-library/react";
export { customRender as render };
```

### Component Testing

```typescript
// src/components/__tests__/video-card.test.tsx
import { render, screen } from "@/lib/test-utils";
import { VideoCard } from "../video-card";
import { mockVideo } from "@/lib/mock-data";
import { describe, it, expect, vi } from "vitest";
import userEvent from "@testing-library/user-event";

describe("VideoCard", () => {
  it("renders video information", () => {
    render(<VideoCard video={mockVideo} onClick={vi.fn()} />);

    expect(screen.getByText(mockVideo.title)).toBeInTheDocument();
    expect(screen.getByText(mockVideo.description)).toBeInTheDocument();
    expect(screen.getByText(mockVideo.duration)).toBeInTheDocument();
  });

  it("calls onClick when clicked", async () => {
    const user = userEvent.setup();
    const mockOnClick = vi.fn();

    render(<VideoCard video={mockVideo} onClick={mockOnClick} />);

    const card = screen.getByRole("button");
    await user.click(card);

    expect(mockOnClick).toHaveBeenCalledTimes(1);
  });

  it("displays thumbnail when provided", () => {
    render(
      <VideoCard
        video={{
          ...mockVideo,
          thumbnailUrl: "https://example.com/thumbnail.jpg",
        }}
        onClick={vi.fn()}
      />
    );

    const thumbnail = screen.getByRole("img");
    expect(thumbnail).toHaveAttribute(
      "src",
      "https://example.com/thumbnail.jpg"
    );
  });
});
```

### Hook Testing

```typescript
// src/hooks/__tests__/use-videos.test.ts
import { renderHook, waitFor } from "@testing-library/react";
import { useVideos } from "../use-api";
import { server } from "@/mocks/server";
import { rest } from "msw";

describe("useVideos", () => {
  it("fetches videos successfully", async () => {
    const { result } = renderHook(() =>
      useVideos({
        organizationId: "organization-1",
      })
    );

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toBeDefined();
    expect(result.current.error).toBeNull();
  });

  it("handles fetch error", async () => {
    server.use(
      rest.get("/api/videos", (req, res, ctx) => {
        return res(ctx.status(500), ctx.json({ error: "Server error" }));
      })
    );

    const { result } = renderHook(() =>
      useVideos({
        organizationId: "organization-1",
      })
    );

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.error).toBe("Failed to fetch videos (500)");
    expect(result.current.data).toBeNull();
  });
});
```

### Utility Testing

```typescript
// src/lib/__tests__/utils.test.ts
import { cn } from "../utils";

describe("cn utility", () => {
  it("merges class names", () => {
    expect(cn("class1", "class2")).toBe("class1 class2");
  });

  it("handles conditional classes", () => {
    expect(cn("base", true && "conditional")).toBe("base conditional");
    expect(cn("base", false && "conditional")).toBe("base");
  });

  it("merges tailwind classes correctly", () => {
    expect(cn("px-4", "px-6")).toBe("px-6");
    expect(cn("text-red-500", "text-blue-500")).toBe("text-blue-500");
  });

  it("handles arrays and objects", () => {
    expect(cn(["class1", "class2"])).toBe("class1 class2");
    expect(cn({ class1: true, class2: false })).toBe("class1");
  });
});
```

## Integration Testing

### API Route Testing

```typescript
// src/app/api/videos/__tests__/route.test.ts
import { NextRequest } from "next/server";
import { GET, POST } from "../route";
import { db } from "@/lib/db";
import { describe, it, expect, vi, beforeEach } from "vitest";

// Mock database
vi.mock("@/lib/db");

describe("/api/videos", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("GET", () => {
    it("returns videos for organization", async () => {
      const mockVideos = [
        {
          id: "video-1",
          title: "Test Video",
          organizationId: "organization-1",
        },
      ];

      vi.mocked(db.select).mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockResolvedValue(mockVideos),
        }),
      } as any);

      const request = new NextRequest(
        "http://localhost:5001/api/videos?organizationId=organization-1"
      );

      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.data).toEqual(mockVideos);
    });

    it("returns 400 for missing organizationId", async () => {
      const request = new NextRequest("http://localhost:5001/api/videos");

      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.success).toBe(false);
      expect(data.error).toBe("Organization ID is required");
    });
  });
});
```

## E2E Testing

### Playwright Configuration

The E2E tests use a multi-project configuration to test both apps across desktop and mobile viewports:

```typescript
// tests/e2e/playwright.config.ts
import { defineConfig, devices } from "@playwright/test";

export default defineConfig({
  testDir: ".",
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: process.env.CI ? [["github"], ["html", { open: "never" }]] : "html",
  use: {
    trace: "on-first-retry",
    screenshot: "only-on-failure",
    video: "on-first-retry",
  },
  projects: [
    // SaaS Application Tests
    {
      name: "saas-desktop",
      testDir: "./saas",
      use: {
        ...devices["Desktop Chrome"],
        baseURL: process.env.SAAS_BASE_URL ?? "http://localhost:5001",
      },
    },
    {
      name: "saas-mobile",
      testDir: "./saas",
      use: {
        ...devices["Pixel 5"],
        baseURL: process.env.SAAS_BASE_URL ?? "http://localhost:5001",
      },
    },
    // Marketing Site Tests
    {
      name: "marketing-desktop",
      testDir: "./marketing",
      use: {
        ...devices["Desktop Chrome"],
        baseURL: process.env.MARKETING_BASE_URL ?? "http://localhost:3001",
      },
    },
    {
      name: "marketing-mobile",
      testDir: "./marketing",
      use: {
        ...devices["Pixel 5"],
        baseURL: process.env.MARKETING_BASE_URL ?? "http://localhost:3001",
      },
    },
  ],
});
```

### Vercel Protection Bypass

When testing against Vercel preview deployments with password protection enabled, provide the bypass secret:

```bash
VERCEL_AUTOMATION_BYPASS_SECRET=your-secret pnpm test:saas
```

The test fixtures automatically add the `x-vercel-protection-bypass` header when this environment variable is set.

### Test File Structure

```
tests/e2e/
├── saas/                    # SaaS application tests
│   ├── auth.spec.ts         # Authentication flow tests
│   ├── landing.spec.ts      # Landing page tests
│   ├── organization.spec.ts # Organization dashboard tests
│   ├── upload.spec.ts       # Video upload tests
│   ├── videos.spec.ts       # Video management tests
│   └── settings.spec.ts     # Settings pages tests
├── marketing/               # Marketing site tests
│   ├── landing.spec.ts      # Marketing landing page
│   └── public-pages.spec.ts # Public pages (docs, blog, etc.)
├── playwright.config.ts     # Playwright configuration
└── package.json             # E2E package dependencies
```

### Running E2E Tests Against Deployed URLs

Tests can target specific deployment URLs:

```bash
# Run SaaS tests against a specific deployment
SAAS_BASE_URL=https://nuclom-saas-xxx.vercel.app pnpm test:saas

# Run Marketing tests against a specific deployment
MARKETING_BASE_URL=https://nuclom-marketing-xxx.vercel.app pnpm test:marketing
```

### E2E Test Examples

```typescript
// tests/e2e/video-management.spec.ts
import { test, expect } from "@playwright/test";

test.describe("Video Management", () => {
  test.beforeEach(async ({ page }) => {
    // Setup authentication
    await page.goto("/login");
    await page.fill('[data-testid="email"]', "test@example.com");
    await page.fill('[data-testid="password"]', "password");
    await page.click('[data-testid="login-button"]');
    await page.waitForURL("/organization-1");
  });

  test("displays videos in organization", async ({ page }) => {
    await page.goto("/organization-1/videos");

    await expect(page.locator('[data-testid="video-card"]')).toBeVisible();
    await expect(page.locator("h1")).toContainText("Videos");
  });

  test("creates new video", async ({ page }) => {
    await page.goto("/organization-1/videos");
    await page.click('[data-testid="create-video-button"]');

    await page.fill('[data-testid="video-title"]', "Test Video");
    await page.fill('[data-testid="video-description"]', "Test Description");
    await page.fill('[data-testid="video-duration"]', "10:30");

    await page.click('[data-testid="save-video-button"]');

    await expect(page.locator('[data-testid="success-message"]')).toBeVisible();
    await expect(page.locator("text=Test Video")).toBeVisible();
  });
});
```

### Page Object Model

```typescript
// tests/e2e/pages/video-page.ts
import { Page, Locator } from "@playwright/test";

export class VideoPage {
  readonly page: Page;
  readonly createButton: Locator;
  readonly titleInput: Locator;
  readonly descriptionInput: Locator;
  readonly durationInput: Locator;
  readonly saveButton: Locator;

  constructor(page: Page) {
    this.page = page;
    this.createButton = page.locator('[data-testid="create-video-button"]');
    this.titleInput = page.locator('[data-testid="video-title"]');
    this.descriptionInput = page.locator('[data-testid="video-description"]');
    this.durationInput = page.locator('[data-testid="video-duration"]');
    this.saveButton = page.locator('[data-testid="save-video-button"]');
  }

  async goto(organizationId: string) {
    await this.page.goto(`/${organizationId}/videos`);
  }

  async createVideo(title: string, description: string, duration: string) {
    await this.createButton.click();
    await this.titleInput.fill(title);
    await this.descriptionInput.fill(description);
    await this.durationInput.fill(duration);
    await this.saveButton.click();
  }

  async expectVideoToExist(title: string) {
    await this.page.waitForSelector(`text=${title}`);
  }
}
```

## Mock Data and MSW

### Mock Service Worker Setup

```typescript
// src/mocks/server.ts
import { setupServer } from "msw/node";
import { handlers } from "./handlers";

export const server = setupServer(...handlers);
```

### API Handlers

```typescript
// src/mocks/handlers.ts
import { rest } from "msw";
import { mockVideos, mockOrganizations } from "@/lib/mock-data";

export const handlers = [
  rest.get("/api/videos", (req, res, ctx) => {
    const organizationId = req.url.searchParams.get("organizationId");

    if (!organizationId) {
      return res(
        ctx.status(400),
        ctx.json({ success: false, error: "Organization ID is required" })
      );
    }

    const videos = mockVideos.filter(
      (v) => v.organizationId === organizationId
    );

    return res(
      ctx.json({
        success: true,
        data: {
          data: videos,
          pagination: {
            page: 1,
            limit: 20,
            total: videos.length,
            totalPages: 1,
          },
        },
      })
    );
  }),

  rest.post("/api/videos", async (req, res, ctx) => {
    const body = await req.json();

    const newVideo = {
      id: `video-${Date.now()}`,
      ...body,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    return res(
      ctx.status(201),
      ctx.json({
        success: true,
        data: newVideo,
      })
    );
  }),
];
```

## Load Testing

Nuclom includes a load testing infrastructure using k6 for performance validation and capacity planning.

### k6 Setup

```bash
# Install k6
brew install k6  # macOS
# or
sudo apt install k6  # Linux
```

### Running Load Tests

```bash
# Run smoke test (quick validation)
k6 run tests/load/auth-flow.js --env PROFILE=smoke

# Run load test (sustained load)
k6 run tests/load/video-page.js --env PROFILE=load

# Run stress test (find breaking point)
k6 run tests/load/search.js --env PROFILE=stress

# Run spike test (sudden traffic burst)
k6 run tests/load/comments.js --env PROFILE=spike

# Run soak test (extended duration)
k6 run tests/load/auth-flow.js --env PROFILE=soak
```

### Test Profiles

| Profile | Duration | VUs | Purpose |
|---------|----------|-----|---------|
| smoke | 1 min | 1-5 | Quick validation |
| load | 5 min | 10-50 | Normal load |
| stress | 10 min | 50-200 | Find limits |
| spike | 3 min | 100-500 | Handle bursts |
| soak | 30 min | 20-50 | Memory leaks |

### Performance Thresholds

```javascript
export const options = {
  thresholds: {
    http_req_duration: ['p(95)<500'],  // 95% under 500ms
    http_req_failed: ['rate<0.01'],    // <1% error rate
    iterations: ['count>100'],          // Minimum iterations
  },
};
```

## Best Practices

### E2E Selector Strategy

Use robust selectors that work across desktop and mobile viewports:

```typescript
// PREFERRED: Role-based selectors (most resilient)
await page.getByRole('button', { name: /sign in/i }).click();
await page.getByRole('link', { name: /create account/i }).click();

// GOOD: Label-based selectors for form fields
await page.getByLabel('Email').fill('test@example.com');
await page.getByLabel('Password').fill('password123');

// ACCEPTABLE: Test ID selectors for complex components
await page.getByTestId('video-upload-dropzone').click();

// AVOID: Text selectors that may match multiple elements or fail on mobile
// ❌ await page.getByText(/private beta/i).click();  // May not find text in badges
// ✅ await page.getByRole('button', { name: /request access/i }).click();
```

**Mobile-Specific Considerations:**
- Text inside badges or decorative elements may have different DOM structures
- Use role-based selectors which are more resilient to layout changes
- Test with actual mobile device profiles (e.g., `devices["Pixel 5"]`)

<Note>
**Test Organization**
1. Group related tests in describe blocks
2. Use descriptive test names
3. Follow AAA pattern (Arrange, Act, Assert)
4. Keep tests isolated and independent
5. Use appropriate test types for different scenarios
</Note>

<Note>
**Test Data**
1. Use factories for test data creation
2. Clean up after each test
3. Use realistic data that reflects real usage
4. Mock external dependencies
5. Use separate test databases
</Note>

### Coverage Goals

| Test Type | Coverage Goal |
|-----------|---------------|
| Unit Tests | 80%+ coverage |
| Integration Tests | Critical paths covered |
| E2E Tests | Happy path and error scenarios |
| Visual Tests | Component rendering |

### CI/CD Integration

E2E tests run automatically when Vercel deployments complete. The pipeline uses sharding for parallel execution:

```yaml
# .github/workflows/e2e.yml (simplified)
name: E2E Tests

on:
  workflow_dispatch:
    inputs:
      saas_url:
        description: "SaaS deployment URL"
        required: false
      marketing_url:
        description: "Marketing deployment URL"
        required: false
      test_saas:
        description: "Whether to run SaaS tests"
        default: "true"
      test_marketing:
        description: "Whether to run Marketing tests"
        default: "true"

jobs:
  e2e-tests:
    name: Playwright (${{ matrix.shard }}/3)
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3]

    steps:
      - uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "24"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: pnpm --filter @nuclom/e2e exec playwright install chromium --with-deps

      - name: Run SaaS E2E tests
        if: inputs.test_saas == 'true'
        run: pnpm test:saas --shard=${{ matrix.shard }}/3
        working-directory: tests/e2e
        env:
          SAAS_BASE_URL: ${{ inputs.saas_url }}

      - name: Run Marketing E2E tests
        if: inputs.test_marketing == 'true'
        run: pnpm test:marketing --shard=${{ matrix.shard }}/3
        working-directory: tests/e2e
        env:
          MARKETING_BASE_URL: ${{ inputs.marketing_url }}
```

### Vercel Deployment Integration

The `e2e-trigger.yml` workflow coordinates E2E test execution with Vercel deployments:

```yaml
# .github/workflows/e2e-trigger.yml (simplified)
on:
  repository_dispatch:
    types:
      - "vercel.deployment.success"
      - "vercel.deployment.ready"
      - "vercel.deployment.skipped"

jobs:
  trigger-e2e:
    steps:
      - name: Detect affected apps with Turborepo
        run: |
          # Use turbo build --dry-run to detect affected packages
          SAAS_DRY=$(pnpm turbo build --filter=nuclom-saas --dry-run=json)
          MARKETING_DRY=$(pnpm turbo build --filter=nuclom-marketing --dry-run=json)
          # ... determine which apps need testing

      - name: Check deployments and trigger E2E
        uses: actions/github-script@v7
        with:
          script: |
            // Wait for all expected deployments
            // Trigger e2e.yml with deployment URLs
            await github.rest.actions.createWorkflowDispatch({
              workflow_id: 'e2e.yml',
              inputs: {
                saas_url: saasUrl,
                marketing_url: marketingUrl,
                test_saas: String(shouldTestSaas),
                test_marketing: String(shouldTestMarketing),
              }
            });
```

### Handling Skipped Deployments

When Vercel's "Skip Unaffected Projects" feature skips a deployment:

1. Vercel sends a `vercel.deployment.skipped` event
2. The trigger workflow marks that app as "ready" (no deployment to wait for)
3. E2E tests only run for apps that were actually deployed
4. If all deployments are skipped, the E2E workflow reports success without running tests

This ensures documentation-only or package-only changes don't block the CI pipeline waiting for deployments that will never arrive.

## Next Steps

<CardGroup cols={2}>
  <Card title="Components" icon="puzzle-piece" href="/internal/reference/components">
    Learn about the component library
  </Card>
  <Card title="Hooks" icon="code" href="/internal/reference/hooks">
    Understand the hook system
  </Card>
  <Card title="Contributing" icon="code-branch" href="/internal/reference/contributing">
    Read the contributing guidelines
  </Card>
  <Card title="Development Setup" icon="computer" href="/internal/reference/development-setup">
    Set up the development environment
  </Card>
</CardGroup>
