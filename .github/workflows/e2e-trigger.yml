name: E2E Trigger

# Triggered by Vercel repository_dispatch events when deployments complete
# This workflow coordinates between SaaS and Marketing deployments
# and triggers E2E tests when deployments are ready
#
# NOTE: repository_dispatch events only trigger workflows on the default branch.
# The workflow will still checkout the correct commit SHA for testing.
#
# See: https://github.com/vercel/repository-dispatch

on:
  repository_dispatch:
    types:
      # Deployment automatically promoted to production
      - "vercel.deployment.success"
      # Build finished, awaiting promotion (preview deployments)
      - "vercel.deployment.ready"

# Use SHA-based concurrency to handle races between SaaS and Marketing deployments:
# - If SaaS deploys first and starts waiting, then Marketing deploys, the SaaS
#   job gets cancelled and Marketing's job takes over (seeing both URLs ready)
# - This prevents duplicate E2E triggers
concurrency:
  group: e2e-trigger-${{ github.event.client_payload.git.sha }}
  cancel-in-progress: true

jobs:
  trigger-e2e:
    name: Check Deployments
    runs-on: ubuntu-latest
    permissions:
      contents: read
      deployments: read
      actions: write # Required to trigger e2e.yml via workflow_dispatch

    steps:
      - name: Log deployment event
        run: |
          echo "Received Vercel deployment event"
          echo "  Event type: ${{ github.event.action }}"
          echo "  Project: ${{ github.event.client_payload.project.name }}"
          echo "  URL: ${{ github.event.client_payload.url }}"
          echo "  Environment: ${{ github.event.client_payload.environment }}"
          echo "  Git SHA: ${{ github.event.client_payload.git.sha }}"
          echo "  Git Ref: ${{ github.event.client_payload.git.ref }}"

      - name: Check deployments and trigger E2E
        uses: actions/github-script@v7
        with:
          script: |
            const payload = context.payload.client_payload;
            const sha = payload.git.sha;
            const currentUrl = payload.url;
            const projectName = payload.project.name;
            const gitRef = payload.git.ref;

            // Identify deployment type from project name
            const isSaas = projectName.includes('nuclom-saas') || projectName === 'nuclom-saas';
            const isMarketing = projectName.includes('nuclom-marketing') || projectName === 'nuclom-marketing';

            if (!isSaas && !isMarketing) {
              console.log(`Ignoring deployment for project: ${projectName}`);
              return;
            }

            console.log(`Processing ${isSaas ? 'nuclom-saas' : 'nuclom-marketing'} deployment`);
            console.log(`  SHA: ${sha}`);
            console.log(`  URL: ${currentUrl}`);

            // Helper to check all deployment statuses for this SHA
            async function checkDeployments() {
              const { data: deployments } = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: sha,
                per_page: 20
              });

              let saasUrl = null;
              let marketingUrl = null;

              for (const deployment of deployments) {
                const { data: statuses } = await github.rest.repos.listDeploymentStatuses({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: deployment.id,
                  per_page: 1
                });

                if (statuses.length > 0 && statuses[0].state === 'success') {
                  const statusUrl = statuses[0].environment_url || statuses[0].target_url;
                  if (statusUrl?.includes('nuclom-saas')) {
                    saasUrl = statusUrl;
                  } else if (statusUrl?.includes('nuclom-marketing')) {
                    marketingUrl = statusUrl;
                  }
                }
              }

              return { saasUrl, marketingUrl };
            }

            // Helper to trigger E2E workflow
            async function triggerE2E(saasUrl, marketingUrl) {
              // Use git ref from deployment, fallback to default branch
              const ref = gitRef || context.payload.repository.default_branch;

              console.log(`Triggering E2E workflow`);
              console.log(`  Ref: ${ref}`);
              console.log(`  SaaS URL: ${saasUrl}`);
              console.log(`  Marketing URL: ${marketingUrl}`);

              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'e2e.yml',
                ref: ref,
                inputs: {
                  saas_url: saasUrl,
                  marketing_url: marketingUrl,
                  triggered_by_sha: sha
                }
              });

              console.log('E2E workflow triggered successfully');
            }

            // Initial check - include the URL from the current event
            let { saasUrl, marketingUrl } = await checkDeployments();

            // The current event's URL might not be in GitHub's deployment API yet,
            // so add it manually based on the project type
            if (isSaas && !saasUrl) {
              saasUrl = currentUrl;
            } else if (isMarketing && !marketingUrl) {
              marketingUrl = currentUrl;
            }

            console.log(`Current deployment status:`);
            console.log(`  SaaS: ${saasUrl || 'not ready'}`);
            console.log(`  Marketing: ${marketingUrl || 'not ready'}`);

            // Case 1: Both deployments ready - trigger immediately
            if (saasUrl && marketingUrl) {
              console.log('Both deployments ready, triggering E2E tests');
              await triggerE2E(saasUrl, marketingUrl);
              return;
            }

            // Case 2: Only marketing ready - exit silently
            // The SaaS deployment event will handle triggering when ready
            if (marketingUrl && !saasUrl) {
              console.log('Marketing ready, waiting for SaaS deployment event...');
              return;
            }

            // Case 3: Only SaaS ready - wait for marketing (with timeout)
            if (saasUrl && !marketingUrl) {
              console.log('SaaS ready. Waiting up to 10 minutes for marketing...');

              const maxWaitMs = 10 * 60 * 1000; // 10 minutes
              const checkIntervalMs = 30 * 1000; // 30 seconds
              const startTime = Date.now();

              while (Date.now() - startTime < maxWaitMs) {
                // Sleep first to give marketing time to deploy
                await new Promise(resolve => setTimeout(resolve, checkIntervalMs));

                const updated = await checkDeployments();
                if (updated.marketingUrl) {
                  console.log('Marketing deployment detected!');
                  await triggerE2E(updated.saasUrl || saasUrl, updated.marketingUrl);
                  return;
                }

                const elapsed = Math.round((Date.now() - startTime) / 1000);
                const remaining = Math.round((maxWaitMs - (Date.now() - startTime)) / 1000);
                console.log(`Waiting for marketing... (${elapsed}s elapsed, ${remaining}s remaining)`);
              }

              // Timeout reached - fail the workflow
              core.setFailed('Timeout waiting for marketing deployment. Both deployments are required.');
            }

            // Case 4: Neither ready - shouldn't happen but handle gracefully
            if (!saasUrl && !marketingUrl) {
              core.setFailed('Unexpected state: no deployments ready.');
            }
